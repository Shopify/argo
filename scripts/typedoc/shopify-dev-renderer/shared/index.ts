import * as fs from 'fs';
import {v4 as uuidv4} from 'uuid';
import markdownTable from 'markdown-table';
import {Module} from '@shopify/docs-tools';

import type {
  LocalReference,
  RemoteComponent,
  Type,
  Documentation,
  PropertySignature,
  IndexSignature,
  Tag,
} from '@shopify/docs-tools/build/ts/src/types';

export {findExamplesFor, renderExamplesFor, renderExample} from './examples';
export type {Example} from './examples';

export interface Node {
  value: RemoteComponent | Type | LocalReference;
  module: Module | undefined;
}

interface FrontMatter {
  gid: string;
  url: string;
  title: string;
  description?: string;
  hidden?: boolean;
  post_unite?: string;
  feature_flag?: string;
}

type VisibilityFrontMatter = Pick<
  FrontMatter,
  'hidden' | 'post_unite' | 'feature_flag'
>;

export type Visibility =
  | 'hidden'
  | 'postUnite'
  | 'visible'
  | 'betaCheckoutExtensions';

const PIPE = '&#124;';
const BACKTICK = '&#96;';

export function renderYamlFrontMatter(frontMatter: FrontMatter) {
  let matter = '---\n';
  matter += `# This file was autogenerated from shopify/ui-extensions\n`;

  (Object.keys(frontMatter) as (keyof FrontMatter)[]).forEach((key) => {
    matter += `${key}: ${frontMatter[key]}\n`;
  });

  matter += '---\n\n';
  return matter;
}

export const visibilityToFrontMatterMap = new Map<
  Visibility,
  VisibilityFrontMatter
>([
  ['betaCheckoutExtensions', {feature_flag: 'checkout_extensions'}],
  ['hidden', {hidden: true}],
  ['postUnite', {post_unite: 'show'}],
  ['visible', {}],
]);

export function findUuid(file: string) {
  let uuid = uuidv4();
  if (fs.existsSync(file)) {
    const uuidMatch = fs
      .readFileSync(file, 'utf8')
      .match(
        /\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b/g,
      );

    if (uuidMatch != null) {
      uuid = uuidMatch[0];
    }
  }

  return uuid;
}

export function dedupe<T>(array: T[]) {
  return [...new Set(array)];
}

export function propsTable(
  name: string,
  docs: Documentation | undefined,
  properties: (PropertySignature | IndexSignature)[],
  exports: Node[],
  dir: string,
  additionalPropsTables: string[],
  titleAndDocs = true,
  headingLevel = 2,
) {
  let markdown = '';

  if (titleAndDocs && name) {
    let heading = '';
    for (let hh = 0; hh < headingLevel; hh++) {
      heading += '#';
    }
    markdown += `<a name="${name}"></a>\n\n${heading} ${name}\n\n`;
    markdown += `${docs ? `${strip(docs.content).trim()}\n\n` : ''}`;
  } else {
    markdown += '\n';
  }

  const indexSignatures: IndexSignature[] = properties.filter(
    (property): property is IndexSignature =>
      property.kind === 'IndexSignature',
  );
  const propertySignatures: PropertySignature[] = properties.filter(
    (property): property is PropertySignature =>
      property.kind === 'PropertySignature',
  );

  if (indexSignatures?.length) {
    const property = indexSignatures[0];

    markdown += `<code>[${property.index.key}: ${propType(
      property.index.type,
      exports,
      dir,
      additionalPropsTables,
    )}]: ${propType(
      property.value,
      exports,
      dir,
      additionalPropsTables,
    )}</code>`;
  } else if (propertySignatures?.length) {
    const table = [];

    // table header row
    const propertiesHaveParameters =
      propertySignatures.filter(({parameters}) => parameters).length > 0;
    if (propertiesHaveParameters) {
      table.push(['Type', 'Description']);
    } else if (propertySignatures.length > 0) {
      table.push(['Name', 'Type', 'Description']);
    }

    propertySignatures.forEach(
      ({name: propName, optional, value, docs: propDocs, parameters}) => {
        if (propName === 'Checkout::KitchenSink') return;

        if (parameters) {
          const thisParamType = paramsType(
            parameters,
            exports,
            dir,
            additionalPropsTables,
          );
          const thisPropType = propType(
            value,
            exports,
            dir,
            additionalPropsTables,
          );
          const type = `<code>(${thisParamType}): ${thisPropType}</code>`;
          const description = propDocs
            ? newLineToBr(strip(propDocs.content))
            : '';
          table.push([type, description]);
        } else {
          const name = `${propName}${optional ? '?' : ''}`;

          const type = `<code>${propType(
            value,
            exports,
            dir,
            additionalPropsTables,
            false,
            findRepeatingTypes(value, exports),
          )}</code>`;

          const content = propDocs ? strip(propDocs.content) : '';
          const tags = propDocs?.tags?.length
            ? `\n\n${propDocs.tags.map(stringifyTag).join('\n')}`
            : '';

          const getCommentsFromUnion = (obj: Type) => {
            const comments = [];

            if (obj && obj.kind === 'UnionType') {
              for (const type of obj.types) {
                if ('comments' in type && type.comments) {
                  comments.push(
                    `\n\n<code>${propType(
                      type,
                      exports,
                      dir,
                      additionalPropsTables,
                    )}</code>: ${type.comments.join(' ')}`,
                  );
                }
              }
            }

            return comments;
          };

          let comments = [];

          if (value.kind === 'Local') {
            const exported = exports.find(
              (x) => 'name' in x.value && x.value.name === value.name,
            );

            comments = getCommentsFromUnion(exported?.value as Type);
          } else {
            comments = getCommentsFromUnion(value);
          }

          const description = newLineToBr(content + comments.join('') + tags);

          table.push([name, type, description]);
        }
      },
    );

    markdown += markdownTable(table, {
      stringLength: () => 3,
    });
  }

  return markdown;
}

function renderUnionType(
  value: any,
  exports: any,
  dir: any,
  additionalPropsTables: any,
  repeatingTypes: any,
) {
  function replaceGenericParams(type: any, value: any) {
    if (isGenericTypeReplaceable(type, value)) {
      type.params = value.params;
    }

    if (type?.params?.length > 0) {
      type.params.map((typeParam: any) =>
        replaceGenericParams(typeParam, value),
      );
    }
  }

  return value.types
    .map((type: any) => {
      replaceGenericParams(type, value);
      return propType(
        type,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      );
    })
    .join(` ${PIPE} `);
}

export function unionTypeTable(
  value: any,
  exports: Node[],
  dir: string,
  additionalPropsTables: string[],
  repeatingTypes: string[],
) {
  let markdown = '';

  markdown += `\n<a name="${value.name}"></a>\n\n### ${value.name}\n\n`;
  markdown += `${value.docs ? `${strip(value.docs.content).trim()}\n\n` : ''}`;

  if (value.types.some((type: any) => type.comments)) {
    const table = [];
    table.push(['Value', 'Description']);

    for (const type of value.types) {
      table.push([
        `<code>${propType(
          type,
          exports,
          dir,
          additionalPropsTables,
          false,
          repeatingTypes,
        )}</code>`,
        type.comments.join(' '),
      ]);
    }

    markdown += markdownTable(table, {
      stringLength: () => 3,
    });
  } else {
    // get rid of `params` property to render generics as is
    const cleanValue = {
      kind: 'UnionType',
      types: value.types,
    };

    markdown += `<code>${renderUnionType(
      cleanValue,
      exports,
      dir,
      additionalPropsTables,
      repeatingTypes,
    )}</code>`;
  }

  return markdown;
}

function newLineToBr(string: string): string {
  return string.replace(/\n\n+/g, '<br /><br />').replace(/\n/g, ' ');
}

function propType(
  value: any,
  exports: any[],
  dir: string,
  additionalPropsTables: string[],
  inArrayType = false,
  repeatingTypes: string[] = [],
): any {
  let params = '';
  if (value.params != null && value.params.length > 0) {
    // This hacky workaround is necessary to avoid stack overflow
    // due to infinite recursion from a nested parameter being a
    // circular dependency.
    // See: https://github.com/Shopify/ui-extensions/issues/268
    const filteredParams = value.params.filter(
      (nestedParam: any) => !Object.is(nestedParam, value),
    );
    params = `<<wbr>${filteredParams
      .map((param: any) =>
        propType(
          param,
          exports,
          dir,
          additionalPropsTables,
          inArrayType,
          repeatingTypes,
        ),
      )
      .join(', ')}<wbr>>`;
  }
  switch (value.kind) {
    case 'UndefinedType':
      return 'undefined';
    case 'AnyType':
      return 'any';
    case 'NullType':
      return 'null';
    case 'UnknownType':
      return 'unknown';
    case 'VoidType':
      return 'void';
    case 'StringType':
      return 'string';
    case 'BooleanType':
      return 'boolean';
    case 'NeverKeyword':
      return 'never';
    case 'ArrayType':
      return `${propType(
        value.elements,
        exports,
        dir,
        additionalPropsTables,
        true,
        repeatingTypes,
      )}[]`;
    case 'NumberType':
      return 'number';
    case 'BigIntType':
      return 'bigint';
    case 'Local': {
      if (value.selfRef) {
        return anchorLink(value.name);
      }

      const localSource = exports.find(
        ({value: exportValue}: any) =>
          exportValue.name === value.name && exportValue.kind !== 'Local',
      );

      // Do not, under any circumstance mutate exported locals (localSource)
      const local = localSource
        ? JSON.parse(JSON.stringify(localSource))
        : undefined;

      if (local == null) {
        // Show the MethodSignatureType name instead of simply "Unknown"
        if (
          value.name === 'Unknown' &&
          value?.params[0]?.kind === 'MethodSignatureType' &&
          value?.params[0]?.name?.length > 0
        ) {
          return `${value.params[0].name}${params}`;
        }

        // If we have a generic type, but have a param, use that instead
        if (value.name === 'T' && value?.params?.length > 0) {
          return propType(
            value?.params[0],
            exports,
            dir,
            additionalPropsTables,
            inArrayType,
            repeatingTypes,
          );
        }

        return `${value.name}${params}`;
      }

      const markSelfReferences = (obj: any, name: string) => {
        for (const key of Object.keys(obj)) {
          const value = obj[key];

          if (typeof value === 'object') {
            if (value.kind === 'Local' && value.name === name) {
              value.selfRef = true;
            } else {
              markSelfReferences(value, name);
            }
          }
        }
      };

      markSelfReferences(local.value, local.value.name);

      local.value.params = value.params;

      return propType(
        local.value,
        exports,
        dir,
        additionalPropsTables,
        inArrayType,
        repeatingTypes,
      );
    }
    case 'InterfaceType':
      if (value.name === 'ConditionalStyle') {
        return value.name + params;
      }

      additionalPropsTables.push(
        propsTable(
          value.name,
          value.docs,
          value.properties,
          exports,
          dir,
          additionalPropsTables,
          true,
          3,
        ),
      );
      return `${anchorLink(value.name)}${params}`;
    case 'UnionType': {
      if (repeatingTypes.includes(value.name)) {
        additionalPropsTables.push(
          unionTypeTable(
            value,
            exports,
            dir,
            additionalPropsTables,
            repeatingTypes,
          ),
        );

        return `${anchorLink(value.name)}${params}`;
      }

      const values = renderUnionType(
        value,
        exports,
        dir,
        additionalPropsTables,
        repeatingTypes,
      );

      return inArrayType ? `(${values})` : values;
    }
    case 'TypeLiteralType':
      return `{${value.properties
        .map(
          (property: any) =>
            `${property.name}${property.optional ? '?' : ''}${
              property.value.kind === 'FunctionType' ? '' : ': '
            }${propType(
              property.value,
              exports,
              dir,
              additionalPropsTables,
              false,
              repeatingTypes,
            )}`,
        )
        .join(', ')}}`;
    case 'StringLiteralType':
      return `"${value.value}"`;
    case 'NumberLiteralType':
      return `${value.value}`;
    case 'BooleanLiteralType':
      return `${value.value}`;
    case 'TemplateLiteralType': {
      const sortedValues = [...value.quasis, ...value.expressions].sort(
        (first, second) => {
          if (first.start > second.start) {
            return 1;
          } else if (second.start > first.start) {
            return -1;
          }
          return 0;
        },
      );

      const result = sortedValues
        .map((node) => {
          if (node.type === 'TemplateElement') {
            return node.value.cooked ?? node.value.raw;
          }
          return `&dollar;{${propType(
            node.value,
            exports,
            dir,
            additionalPropsTables,
          )}}`;
        })
        .join('');

      return `${BACKTICK}${result}${BACKTICK}`;
    }
    case 'FunctionType':
      return `(${paramsType(
        value.parameters,
        exports,
        dir,
        additionalPropsTables,
      )}) => ${propType(
        value.returnType,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      )}`;
    case 'MethodSignatureType':
      return `(${paramsType(
        value.parameters,
        exports,
        dir,
        additionalPropsTables,
      )}) => ${propType(
        value.returnType,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      )}`;
    case 'MappedType':
      // eslint-disable-next-line no-case-declarations
      const ref = exports.find(
        ({value: exportValue}: any) => exportValue.name === value.ref,
      );
      // special case for Responsive only
      additionalPropsTables.push(responsive(ref, additionalPropsTables));
      return anchorLink(value.name);
    case 'ConditionalType':
      return `${propType(
        value.checkType,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      )} extends ${propType(
        value.extendsType,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      )} ? ${propType(
        value.trueType,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      )} : ${propType(
        value.falseType,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      )}`;
    case 'IndexSignatureType':
      return `[${paramsType(
        value.parameters,
        exports,
        dir,
        additionalPropsTables,
      )}]: ${propType(
        value.properties,
        exports,
        dir,
        additionalPropsTables,
        false,
        repeatingTypes,
      )}`;
    case 'TupleType':
      return `[${value.elements
        .map((element: any) => {
          return propType(
            element,
            exports,
            dir,
            additionalPropsTables,
            false,
            repeatingTypes,
          );
        })
        .join(', ')}]`;
    case 'UndocumentedType':
      if (value.kind === 'UndocumentedType' && value.name?.length > 0) {
        return value.name;
      }
      console.warn(
        '🚨 A type could not be resolved and is being used in documentation showing as `UndocumentedType`. Check the output for the affected docs.',
      );
      return value.kind;
    default:
      return value.kind;
  }
}

function anchorLink(string: any): string {
  return `<a href="#${string.toLowerCase()}">${string}</a>`;
}

function sentenceCaseTagName(tagName: string) {
  const input = tagName.slice(1);
  const result = input.replace(/([A-Z])/g, ' $1').toLowerCase();
  return result.charAt(0).toUpperCase() + result.slice(1);
}

function stringifyTag(tag: Tag) {
  let string = sentenceCaseTagName(tag.name);
  if (tag.content) {
    string += `: <code>${tag.content}</code>`;
  }
  return string;
}

function escapeHTML(html: string) {
  const chars: {[key: string]: string} = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&#34;',
  };
  return html.replace(/[&<>"]/g, (tag: string) => chars[tag] || tag);
}

export function strip(content: string) {
  return escapeHTML(
    content
      .trim()
      .replace('/**', '')
      .replace('*/', '')
      .replace(/\n \* /g, '\n')
      .replace(/\n \*/g, '\n')
      .replace(/\n\n \* /g, '\n\n'),
  );
}

/**
 * extract first sentence (line or up to '.') for yaml description field
 */
export function firstSentence(content: string) {
  const lines = content.split(/(\n|\. )/g);
  let firstSentence = lines.length ? lines[0] : content;

  // try to split on period if first line doesn't have one
  if (lines.length && lines[0].indexOf('.') !== 0) {
    const sentences = content.split('.');
    firstSentence = sentences[0];
  }

  if (firstSentence[firstSentence.length - 1] !== '.') {
    firstSentence += '.';
  }
  return firstSentence.replace('\n', ' ');
}

function paramsType(
  params: any[],
  exports: any[],
  dir: string,
  additionalPropsTables: string[],
) {
  return params
    .map(
      (param) =>
        `${param.name}: ${propType(
          param.type,
          exports,
          dir,
          additionalPropsTables,
          false,
        )}`,
    )
    .join(', ');
}

function responsive(breakpoint: any, additionalPropsTables: string[]) {
  const breakpoints = propType(breakpoint.value, [], '', additionalPropsTables);

  let markdown = '<a name="Responsive"></a>\n\n### Responsive\n\n';

  markdown += `Responsive is a [Mapped Type](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html). It allows you to set different values at different breakpoints by providing an object where the keys are Breakpoints: <code>${breakpoints}</code>\n\n`;
  markdown +=
    'For example, if a property accepts `number | Responsive`, it would accept a number or an object where the keys are Breakpoints and the values are numbers:\n\n';
  markdown += `\`\`\`js
{
  'base': 1,
  'small': 0.5,
  'large': 2
}
\`\`\`\n\n`;

  return markdown;
}

function isGenericTypeReplaceable(type: any, value: any) {
  return type.name === 'T' && !type.params && value?.params?.length > 0;
}

export function mkdir(directory: any) {
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, {recursive: true});
  }
}

function findRepeatingTypes(obj: Type, exports: Node[]) {
  const occurrences: any = {};

  function traverse(obj?: Type, stash?: any): any {
    if (!obj) {
      return;
    }

    if ('name' in obj && obj.name) {
      if (obj.name === 'T') {
        traverse(stash);
        return;
      }

      let exported;

      if (obj.kind === 'Local') {
        exported = exports.find(
          (x) =>
            x.value !== obj && 'name' in x.value && x.value.name === obj.name,
        );
      }

      if (exported) {
        if (exported.value.kind !== 'InterfaceType') {
          traverse(exported.value as Type, (obj as any)?.params?.[0]);
          return;
        } else if (stash) {
          traverse(stash);
          return;
        }
      } else {
        occurrences[obj.name] = occurrences[obj.name] || 0;
        occurrences[obj.name]++;
      }
    }

    if ('params' in obj && obj.params) {
      for (const param of obj.params) {
        traverse(param as Type, stash);
      }
    }

    if ('properties' in obj && obj.properties) {
      for (const property of obj.properties) {
        traverse(property.value, stash);
      }
    }

    if ('types' in obj && obj.types) {
      for (const type of obj.types) {
        traverse(type, stash);
      }
    }

    if ('elements' in obj && obj.elements) {
      if (Array.isArray(obj.elements)) {
        for (const element of obj.elements) {
          traverse(element, stash);
        }
      } else {
        traverse(obj.elements, stash);
      }
    }
  }

  traverse(obj);

  const repeatingTypes = [];

  for (const name in occurrences) {
    if (occurrences[name] > 1) {
      repeatingTypes.push(name);
    }
  }

  return repeatingTypes;
}
